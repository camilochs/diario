# Principios de la programación

- **Contenido**: Notas sobre cada sección de este libro.
- **Metadata**:
	- **Fecha de inicio**: 25/08/2021
- ### <span style="color: DeepSkyBlue;">Índice</span>
	- * [[Parte I - Introducción]]
		- 1\. Introducción a la programación
			- 1.1\. La matemática que necesita un programador
			- 1.2. Conceptos básicos
				- 1.2.1. Diagramas de flujo
				- 1.2.2. Pseudocódigo
				- 1.2.3. Programando en un entorno visual
			- 1.3. Algoritmos y estructuras de datos
			- 1.4. Pensamiento computacional
				- 1.4.1. Abstracción
				- 1.4.2. Descomposición y modularidad
				- 1.4.3. Tolerancia a la complejidad
				- 1.4.4. Exactitud y heurística
		- 2\.  Una breve historia de la informática
			- 2.1\. En la prehistoria de la informática
			- 2.2\. Siglo XX: El surgimiento de la informática
			- 2.3\. Era actual
	- * **Parte II - Principios**
		- * Técnicos
			- I. Diseño
			- II. Estado
			- III. Recurso
			- IV. Coordinación
			- V. Transformación
		- * Conductuales
			- VI. Documentación
			- VII. Evolución
			- VIII. Ethos
	- * **Parte III - Sistemas informáticos**
		- 3\.  Introducción a los sistemas informáticos
			- 3.1. Lenguajes de programación
				- 3.1.1. Problemas generales
				- 3.1.2. Problemas particulares
			- 3.2\. Sistemas operativos
				- 3.2.1. UNIX
				- 3.2.2. Windows
				- 3.2.3. MacOS
			- 3.3\. Bases de datos
				- 3.3.1. Relacionales
				- 3.3.2. No relacionales
			- 3.4\. Sistemas distribuidos
				- 3.4.1. Procesamientos de datos en la nube
				- 3.4.2. Sistemas de colas distribuidas
			- 3.5\. Inteligencia artificial
				- 3.5.1. Sistemas expertos
				- 3.5.2. Autómatas celulares
				- 3.5.3. Machine learning
					- 3.5.3.1. Deep Learning
			- 3.6\. Teoría de la computación
				- 3.6.1. Máquina de Turing
				- 3.6.2. Cálculo lambda
			- 3.7\. Computación cuántica
				- 3.7.1. Puertas cuánticas
				- 3.7.1. Modelos de computación
				- 3.7.3. Algoritmos y lenguajes cuánticos
				- 3.7.4. Retos futuros: corrección de errores y ordenadores
		- 
	- * **Parte IV - Proyectos de software**
		- 4\. Buenas prácticas
			- 4.1. Sobre el código
			- 4.2. Sobre el equipo
		- 5\. Ciclo de vida de un proyecto
			- 5.1. Requerimientos
			- 5.2. Especificación
			- 5.3. Diseño
			- 5.4. Implementación
			- 5.5. Pruebas
			- 5.6. Despliegue
			- 5.7. Código legado y su mantenimiento
		- 6\. Tipos de proyectos de software
			- 6.1. De sistemas
				- 6.1.1. Sistmeas operativos
				- 6.1.2. Lenguajes de programación
					- 6.1.2.1. Compiladores
					- 6.1.2.2. Intepretes
					- 6.1.2.3. Enlazador (_linker_) y cargador (_loader_)
				- 6.1.3. Herramientas y utilidades
			- 6.2. De aplicación
				- 6.2.1. Web
				- 6.2.2. IOT
				- 6.2.3. Videojuegos
				- 6.2.4. Criptografía
				- 6.2.5. Bases de datos
				- 6.2.6. Ciberseguridad
			- 6.3. De datos
				- 6.3.1. Big data
				- 6.3.2. Ciencia de datos
			- 6.4. Para la investigación científica
				- 6.4.1. Leyendo artículos científicos
				- 6.4.2. Creando prototipos
				- 6.4.3. Experimentos y análisis estadístico
	- * **Parte V - Consejos para construir una carrera exitosa como programador**
		- 7\. Sobre el aprendiazaje de la programación
			- 7.1. Sobre la vida personal
			- 7.2. Sobre el mundo laboral
			- 7.3. Más allá de lo técnico
	- **Glosario**
	- **Epílogo**
	- **Referencias**
	- **Índice alfabético**
- ### Notas generales:
	- Cada capítulo debe presentar al comienzo los objetivos de este, y al final, añadir un resumen.
	- Gran presencia de historias que hagan uso de metáforas y analogías, para lograr hacer la lectura más atractiva y amena.
		- Hacer que esas historias hagan al lector identificarse.
		- ¿Se acuerda cuando escucha por primera vez una canción? Quizás no le gusta tanto, pero una vez la escucha más veces, mejor se va haciendo, encuentra nuevos detalles que pasaron antes desapercibido. Algo similar ocurre con un lenguaje de programación que a primera vista no le gusto.
		- 
	- 
